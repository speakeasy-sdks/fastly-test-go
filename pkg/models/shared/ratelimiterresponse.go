// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"Fastly/pkg/utils"
	"encoding/json"
	"fmt"
	"time"
)

// RateLimiterResponseAction - The action to take when a rate limiter violation is detected.
type RateLimiterResponseAction string

const (
	RateLimiterResponseActionResponse       RateLimiterResponseAction = "response"
	RateLimiterResponseActionResponseObject RateLimiterResponseAction = "response_object"
	RateLimiterResponseActionLogOnly        RateLimiterResponseAction = "log_only"
)

func (e RateLimiterResponseAction) ToPointer() *RateLimiterResponseAction {
	return &e
}

func (e *RateLimiterResponseAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "response":
		fallthrough
	case "response_object":
		fallthrough
	case "log_only":
		*e = RateLimiterResponseAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RateLimiterResponseAction: %v", v)
	}
}

type RateLimiterResponseHTTPMethods string

const (
	RateLimiterResponseHTTPMethodsHead    RateLimiterResponseHTTPMethods = "HEAD"
	RateLimiterResponseHTTPMethodsOptions RateLimiterResponseHTTPMethods = "OPTIONS"
	RateLimiterResponseHTTPMethodsGet     RateLimiterResponseHTTPMethods = "GET"
	RateLimiterResponseHTTPMethodsPost    RateLimiterResponseHTTPMethods = "POST"
	RateLimiterResponseHTTPMethodsPut     RateLimiterResponseHTTPMethods = "PUT"
	RateLimiterResponseHTTPMethodsPatch   RateLimiterResponseHTTPMethods = "PATCH"
	RateLimiterResponseHTTPMethodsDelete  RateLimiterResponseHTTPMethods = "DELETE"
	RateLimiterResponseHTTPMethodsTrace   RateLimiterResponseHTTPMethods = "TRACE"
)

func (e RateLimiterResponseHTTPMethods) ToPointer() *RateLimiterResponseHTTPMethods {
	return &e
}

func (e *RateLimiterResponseHTTPMethods) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HEAD":
		fallthrough
	case "OPTIONS":
		fallthrough
	case "GET":
		fallthrough
	case "POST":
		fallthrough
	case "PUT":
		fallthrough
	case "PATCH":
		fallthrough
	case "DELETE":
		fallthrough
	case "TRACE":
		*e = RateLimiterResponseHTTPMethods(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RateLimiterResponseHTTPMethods: %v", v)
	}
}

// RateLimiterResponseLoggerType - Name of the type of logging endpoint to be used when action is `log_only`. The logging endpoint type is used to determine the appropriate log format to use when emitting log entries.
type RateLimiterResponseLoggerType string

const (
	RateLimiterResponseLoggerTypeAzureblob       RateLimiterResponseLoggerType = "azureblob"
	RateLimiterResponseLoggerTypeBigquery        RateLimiterResponseLoggerType = "bigquery"
	RateLimiterResponseLoggerTypeCloudfiles      RateLimiterResponseLoggerType = "cloudfiles"
	RateLimiterResponseLoggerTypeDatadog         RateLimiterResponseLoggerType = "datadog"
	RateLimiterResponseLoggerTypeDigitalocean    RateLimiterResponseLoggerType = "digitalocean"
	RateLimiterResponseLoggerTypeElasticsearch   RateLimiterResponseLoggerType = "elasticsearch"
	RateLimiterResponseLoggerTypeFtp             RateLimiterResponseLoggerType = "ftp"
	RateLimiterResponseLoggerTypeGcs             RateLimiterResponseLoggerType = "gcs"
	RateLimiterResponseLoggerTypeGoogleanalytics RateLimiterResponseLoggerType = "googleanalytics"
	RateLimiterResponseLoggerTypeHeroku          RateLimiterResponseLoggerType = "heroku"
	RateLimiterResponseLoggerTypeHoneycomb       RateLimiterResponseLoggerType = "honeycomb"
	RateLimiterResponseLoggerTypeHTTP            RateLimiterResponseLoggerType = "http"
	RateLimiterResponseLoggerTypeHTTPS           RateLimiterResponseLoggerType = "https"
	RateLimiterResponseLoggerTypeKafka           RateLimiterResponseLoggerType = "kafka"
	RateLimiterResponseLoggerTypeKinesis         RateLimiterResponseLoggerType = "kinesis"
	RateLimiterResponseLoggerTypeLogentries      RateLimiterResponseLoggerType = "logentries"
	RateLimiterResponseLoggerTypeLoggly          RateLimiterResponseLoggerType = "loggly"
	RateLimiterResponseLoggerTypeLogshuttle      RateLimiterResponseLoggerType = "logshuttle"
	RateLimiterResponseLoggerTypeNewrelic        RateLimiterResponseLoggerType = "newrelic"
	RateLimiterResponseLoggerTypeOpenstack       RateLimiterResponseLoggerType = "openstack"
	RateLimiterResponseLoggerTypePapertrail      RateLimiterResponseLoggerType = "papertrail"
	RateLimiterResponseLoggerTypePubsub          RateLimiterResponseLoggerType = "pubsub"
	RateLimiterResponseLoggerTypeS3              RateLimiterResponseLoggerType = "s3"
	RateLimiterResponseLoggerTypeScalyr          RateLimiterResponseLoggerType = "scalyr"
	RateLimiterResponseLoggerTypeSftp            RateLimiterResponseLoggerType = "sftp"
	RateLimiterResponseLoggerTypeSplunk          RateLimiterResponseLoggerType = "splunk"
	RateLimiterResponseLoggerTypeStackdriver     RateLimiterResponseLoggerType = "stackdriver"
	RateLimiterResponseLoggerTypeSumologic       RateLimiterResponseLoggerType = "sumologic"
	RateLimiterResponseLoggerTypeSyslog          RateLimiterResponseLoggerType = "syslog"
)

func (e RateLimiterResponseLoggerType) ToPointer() *RateLimiterResponseLoggerType {
	return &e
}

func (e *RateLimiterResponseLoggerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azureblob":
		fallthrough
	case "bigquery":
		fallthrough
	case "cloudfiles":
		fallthrough
	case "datadog":
		fallthrough
	case "digitalocean":
		fallthrough
	case "elasticsearch":
		fallthrough
	case "ftp":
		fallthrough
	case "gcs":
		fallthrough
	case "googleanalytics":
		fallthrough
	case "heroku":
		fallthrough
	case "honeycomb":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "kafka":
		fallthrough
	case "kinesis":
		fallthrough
	case "logentries":
		fallthrough
	case "loggly":
		fallthrough
	case "logshuttle":
		fallthrough
	case "newrelic":
		fallthrough
	case "openstack":
		fallthrough
	case "papertrail":
		fallthrough
	case "pubsub":
		fallthrough
	case "s3":
		fallthrough
	case "scalyr":
		fallthrough
	case "sftp":
		fallthrough
	case "splunk":
		fallthrough
	case "stackdriver":
		fallthrough
	case "sumologic":
		fallthrough
	case "syslog":
		*e = RateLimiterResponseLoggerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RateLimiterResponseLoggerType: %v", v)
	}
}

// RateLimiterResponseResponse - Custom response to be sent when the rate limit is exceeded. Required if `action` is `response`.
type RateLimiterResponseResponse struct {
	// Response body for custom limit enforcement response.
	Content *string `json:"content,omitempty"`
	// MIME type for custom limit enforcement response.
	ContentType *string `json:"content_type,omitempty"`
	// HTTP status code for custom limit enforcement response.
	Status *int64 `json:"status,omitempty"`
}

func (o *RateLimiterResponseResponse) GetContent() *string {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *RateLimiterResponseResponse) GetContentType() *string {
	if o == nil {
		return nil
	}
	return o.ContentType
}

func (o *RateLimiterResponseResponse) GetStatus() *int64 {
	if o == nil {
		return nil
	}
	return o.Status
}

// RateLimiterResponseWindowSize - Number of seconds during which the RPS limit must be exceeded in order to trigger a violation.
type RateLimiterResponseWindowSize int64

const (
	RateLimiterResponseWindowSizeOne   RateLimiterResponseWindowSize = 1
	RateLimiterResponseWindowSizeTen   RateLimiterResponseWindowSize = 10
	RateLimiterResponseWindowSizeSixty RateLimiterResponseWindowSize = 60
)

func (e RateLimiterResponseWindowSize) ToPointer() *RateLimiterResponseWindowSize {
	return &e
}

func (e *RateLimiterResponseWindowSize) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		fallthrough
	case 10:
		fallthrough
	case 60:
		*e = RateLimiterResponseWindowSize(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RateLimiterResponseWindowSize: %v", v)
	}
}

type RateLimiterResponse struct {
	// The action to take when a rate limiter violation is detected.
	Action *RateLimiterResponseAction `json:"action,omitempty"`
	// Array of VCL variables used to generate a counter key to identify a client. Example variables include `req.http.Fastly-Client-IP`, `req.http.User-Agent`, or a custom header like `req.http.API-Key`.
	ClientKey []string `json:"client_key,omitempty"`
	// Date and time in ISO 8601 format.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// Date and time in ISO 8601 format.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// Revision number of the rate limiting feature implementation. Defaults to the most recent revision.
	FeatureRevision *int64 `json:"feature_revision,omitempty"`
	// Array of HTTP methods to apply rate limiting to.
	HTTPMethods []RateLimiterResponseHTTPMethods `json:"http_methods,omitempty"`
	// Alphanumeric string identifying the rate limiter.
	ID *string `json:"id,omitempty"`
	// Name of the type of logging endpoint to be used when action is `log_only`. The logging endpoint type is used to determine the appropriate log format to use when emitting log entries.
	LoggerType *RateLimiterResponseLoggerType `json:"logger_type,omitempty"`
	// A human readable name for the rate limiting rule.
	Name *string `json:"name,omitempty"`
	// Length of time in minutes that the rate limiter is in effect after the initial violation is detected.
	PenaltyBoxDuration *int64 `json:"penalty_box_duration,omitempty"`
	// Custom response to be sent when the rate limit is exceeded. Required if `action` is `response`.
	Response *RateLimiterResponseResponse `json:"response,omitempty"`
	// Name of existing response object. Required if `action` is `response_object`. Note that the rate limiter response is only updated to reflect the response object content when saving the rate limiter configuration.
	ResponseObjectName *string `json:"response_object_name,omitempty"`
	// Upper limit of requests per second allowed by the rate limiter.
	RpsLimit  *int64  `json:"rps_limit,omitempty"`
	ServiceID *string `json:"service_id,omitempty"`
	// Date and time in ISO 8601 format.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	// The name of an Edge Dictionary containing URIs as keys. If not defined or `null`, all origin URIs will be rate limited.
	URIDictionaryName *string `json:"uri_dictionary_name,omitempty"`
	Version           *int64  `json:"version,omitempty"`
	// Number of seconds during which the RPS limit must be exceeded in order to trigger a violation.
	WindowSize *RateLimiterResponseWindowSize `json:"window_size,omitempty"`
}

func (r RateLimiterResponse) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RateLimiterResponse) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *RateLimiterResponse) GetAction() *RateLimiterResponseAction {
	if o == nil {
		return nil
	}
	return o.Action
}

func (o *RateLimiterResponse) GetClientKey() []string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *RateLimiterResponse) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *RateLimiterResponse) GetDeletedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *RateLimiterResponse) GetFeatureRevision() *int64 {
	if o == nil {
		return nil
	}
	return o.FeatureRevision
}

func (o *RateLimiterResponse) GetHTTPMethods() []RateLimiterResponseHTTPMethods {
	if o == nil {
		return nil
	}
	return o.HTTPMethods
}

func (o *RateLimiterResponse) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *RateLimiterResponse) GetLoggerType() *RateLimiterResponseLoggerType {
	if o == nil {
		return nil
	}
	return o.LoggerType
}

func (o *RateLimiterResponse) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *RateLimiterResponse) GetPenaltyBoxDuration() *int64 {
	if o == nil {
		return nil
	}
	return o.PenaltyBoxDuration
}

func (o *RateLimiterResponse) GetResponse() *RateLimiterResponseResponse {
	if o == nil {
		return nil
	}
	return o.Response
}

func (o *RateLimiterResponse) GetResponseObjectName() *string {
	if o == nil {
		return nil
	}
	return o.ResponseObjectName
}

func (o *RateLimiterResponse) GetRpsLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.RpsLimit
}

func (o *RateLimiterResponse) GetServiceID() *string {
	if o == nil {
		return nil
	}
	return o.ServiceID
}

func (o *RateLimiterResponse) GetUpdatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *RateLimiterResponse) GetURIDictionaryName() *string {
	if o == nil {
		return nil
	}
	return o.URIDictionaryName
}

func (o *RateLimiterResponse) GetVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *RateLimiterResponse) GetWindowSize() *RateLimiterResponseWindowSize {
	if o == nil {
		return nil
	}
	return o.WindowSize
}
