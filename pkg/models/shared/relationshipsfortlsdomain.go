// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"Fastly/pkg/utils"
	"errors"
)

type RelationshipsForTLSDomain2TLSCertificates struct {
	Data []RelationshipMemberTLSCertificate `json:"data,omitempty"`
}

func (o *RelationshipsForTLSDomain2TLSCertificates) GetData() []RelationshipMemberTLSCertificate {
	if o == nil {
		return nil
	}
	return o.Data
}

// RelationshipsForTLSDomain2 - The list of all the [TLS certificates](#tls_certificates) that include this domain in their SAN list.
type RelationshipsForTLSDomain2 struct {
	TLSCertificates *RelationshipsForTLSDomain2TLSCertificates `json:"tls_certificates,omitempty"`
}

func (o *RelationshipsForTLSDomain2) GetTLSCertificates() *RelationshipsForTLSDomain2TLSCertificates {
	if o == nil {
		return nil
	}
	return o.TLSCertificates
}

type RelationshipsForTLSDomain1TLSActivations struct {
	Data []RelationshipMemberTLSActivation `json:"data,omitempty"`
}

func (o *RelationshipsForTLSDomain1TLSActivations) GetData() []RelationshipMemberTLSActivation {
	if o == nil {
		return nil
	}
	return o.Data
}

// RelationshipsForTLSDomain1 - The list of [TLS activations](#tls_activations) that exist for the domain. If empty, then this domain is not enabled to serve TLS traffic.
type RelationshipsForTLSDomain1 struct {
	TLSActivations *RelationshipsForTLSDomain1TLSActivations `json:"tls_activations,omitempty"`
}

func (o *RelationshipsForTLSDomain1) GetTLSActivations() *RelationshipsForTLSDomain1TLSActivations {
	if o == nil {
		return nil
	}
	return o.TLSActivations
}

type RelationshipsForTLSDomainType string

const (
	RelationshipsForTLSDomainTypeRelationshipsForTLSDomain1   RelationshipsForTLSDomainType = "relationships_for_tls_domain_1"
	RelationshipsForTLSDomainTypeRelationshipsForTLSDomain2   RelationshipsForTLSDomainType = "relationships_for_tls_domain_2"
	RelationshipsForTLSDomainTypeRelationshipTLSSubscriptions RelationshipsForTLSDomainType = "relationship_tls_subscriptions"
)

type RelationshipsForTLSDomain struct {
	RelationshipsForTLSDomain1   *RelationshipsForTLSDomain1
	RelationshipsForTLSDomain2   *RelationshipsForTLSDomain2
	RelationshipTLSSubscriptions *RelationshipTLSSubscriptions

	Type RelationshipsForTLSDomainType
}

func CreateRelationshipsForTLSDomainRelationshipsForTLSDomain1(relationshipsForTLSDomain1 RelationshipsForTLSDomain1) RelationshipsForTLSDomain {
	typ := RelationshipsForTLSDomainTypeRelationshipsForTLSDomain1

	return RelationshipsForTLSDomain{
		RelationshipsForTLSDomain1: &relationshipsForTLSDomain1,
		Type:                       typ,
	}
}

func CreateRelationshipsForTLSDomainRelationshipsForTLSDomain2(relationshipsForTLSDomain2 RelationshipsForTLSDomain2) RelationshipsForTLSDomain {
	typ := RelationshipsForTLSDomainTypeRelationshipsForTLSDomain2

	return RelationshipsForTLSDomain{
		RelationshipsForTLSDomain2: &relationshipsForTLSDomain2,
		Type:                       typ,
	}
}

func CreateRelationshipsForTLSDomainRelationshipTLSSubscriptions(relationshipTLSSubscriptions RelationshipTLSSubscriptions) RelationshipsForTLSDomain {
	typ := RelationshipsForTLSDomainTypeRelationshipTLSSubscriptions

	return RelationshipsForTLSDomain{
		RelationshipTLSSubscriptions: &relationshipTLSSubscriptions,
		Type:                         typ,
	}
}

func (u *RelationshipsForTLSDomain) UnmarshalJSON(data []byte) error {

	relationshipsForTLSDomain1 := new(RelationshipsForTLSDomain1)
	if err := utils.UnmarshalJSON(data, &relationshipsForTLSDomain1, "", true, true); err == nil {
		u.RelationshipsForTLSDomain1 = relationshipsForTLSDomain1
		u.Type = RelationshipsForTLSDomainTypeRelationshipsForTLSDomain1
		return nil
	}

	relationshipsForTLSDomain2 := new(RelationshipsForTLSDomain2)
	if err := utils.UnmarshalJSON(data, &relationshipsForTLSDomain2, "", true, true); err == nil {
		u.RelationshipsForTLSDomain2 = relationshipsForTLSDomain2
		u.Type = RelationshipsForTLSDomainTypeRelationshipsForTLSDomain2
		return nil
	}

	relationshipTLSSubscriptions := new(RelationshipTLSSubscriptions)
	if err := utils.UnmarshalJSON(data, &relationshipTLSSubscriptions, "", true, true); err == nil {
		u.RelationshipTLSSubscriptions = relationshipTLSSubscriptions
		u.Type = RelationshipsForTLSDomainTypeRelationshipTLSSubscriptions
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RelationshipsForTLSDomain) MarshalJSON() ([]byte, error) {
	if u.RelationshipsForTLSDomain1 != nil {
		return utils.MarshalJSON(u.RelationshipsForTLSDomain1, "", true)
	}

	if u.RelationshipsForTLSDomain2 != nil {
		return utils.MarshalJSON(u.RelationshipsForTLSDomain2, "", true)
	}

	if u.RelationshipTLSSubscriptions != nil {
		return utils.MarshalJSON(u.RelationshipTLSSubscriptions, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}
