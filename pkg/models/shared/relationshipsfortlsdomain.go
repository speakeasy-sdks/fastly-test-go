// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"Fastly/pkg/utils"
	"errors"
)

type RelationshipsForTLSDomainType string

const (
	RelationshipsForTLSDomainTypeRelationshipTLSActivations   RelationshipsForTLSDomainType = "relationship_tls_activations"
	RelationshipsForTLSDomainTypeRelationshipTLSCertificates  RelationshipsForTLSDomainType = "relationship_tls_certificates"
	RelationshipsForTLSDomainTypeRelationshipTLSSubscriptions RelationshipsForTLSDomainType = "relationship_tls_subscriptions"
)

type RelationshipsForTLSDomain struct {
	RelationshipTLSActivations   *RelationshipTLSActivations
	RelationshipTLSCertificates  *RelationshipTLSCertificates
	RelationshipTLSSubscriptions *RelationshipTLSSubscriptions

	Type RelationshipsForTLSDomainType
}

func CreateRelationshipsForTLSDomainRelationshipTLSActivations(relationshipTLSActivations RelationshipTLSActivations) RelationshipsForTLSDomain {
	typ := RelationshipsForTLSDomainTypeRelationshipTLSActivations

	return RelationshipsForTLSDomain{
		RelationshipTLSActivations: &relationshipTLSActivations,
		Type:                       typ,
	}
}

func CreateRelationshipsForTLSDomainRelationshipTLSCertificates(relationshipTLSCertificates RelationshipTLSCertificates) RelationshipsForTLSDomain {
	typ := RelationshipsForTLSDomainTypeRelationshipTLSCertificates

	return RelationshipsForTLSDomain{
		RelationshipTLSCertificates: &relationshipTLSCertificates,
		Type:                        typ,
	}
}

func CreateRelationshipsForTLSDomainRelationshipTLSSubscriptions(relationshipTLSSubscriptions RelationshipTLSSubscriptions) RelationshipsForTLSDomain {
	typ := RelationshipsForTLSDomainTypeRelationshipTLSSubscriptions

	return RelationshipsForTLSDomain{
		RelationshipTLSSubscriptions: &relationshipTLSSubscriptions,
		Type:                         typ,
	}
}

func (u *RelationshipsForTLSDomain) UnmarshalJSON(data []byte) error {

	relationshipTLSActivations := new(RelationshipTLSActivations)
	if err := utils.UnmarshalJSON(data, &relationshipTLSActivations, "", true, true); err == nil {
		u.RelationshipTLSActivations = relationshipTLSActivations
		u.Type = RelationshipsForTLSDomainTypeRelationshipTLSActivations
		return nil
	}

	relationshipTLSCertificates := new(RelationshipTLSCertificates)
	if err := utils.UnmarshalJSON(data, &relationshipTLSCertificates, "", true, true); err == nil {
		u.RelationshipTLSCertificates = relationshipTLSCertificates
		u.Type = RelationshipsForTLSDomainTypeRelationshipTLSCertificates
		return nil
	}

	relationshipTLSSubscriptions := new(RelationshipTLSSubscriptions)
	if err := utils.UnmarshalJSON(data, &relationshipTLSSubscriptions, "", true, true); err == nil {
		u.RelationshipTLSSubscriptions = relationshipTLSSubscriptions
		u.Type = RelationshipsForTLSDomainTypeRelationshipTLSSubscriptions
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RelationshipsForTLSDomain) MarshalJSON() ([]byte, error) {
	if u.RelationshipTLSActivations != nil {
		return utils.MarshalJSON(u.RelationshipTLSActivations, "", true)
	}

	if u.RelationshipTLSCertificates != nil {
		return utils.MarshalJSON(u.RelationshipTLSCertificates, "", true)
	}

	if u.RelationshipTLSSubscriptions != nil {
		return utils.MarshalJSON(u.RelationshipTLSSubscriptions, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}
