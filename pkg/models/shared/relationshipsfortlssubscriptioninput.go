// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"Fastly/pkg/utils"
	"errors"
)

// RelationshipsForTLSSubscription2Input - The common name associated with the subscription generated by Fastly TLS. Optional. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
type RelationshipsForTLSSubscription2Input struct {
	CommonName *RelationshipMemberTLSDomainInput `json:"common_name,omitempty"`
}

func (o *RelationshipsForTLSSubscription2Input) GetCommonName() *RelationshipMemberTLSDomainInput {
	if o == nil {
		return nil
	}
	return o.CommonName
}

type RelationshipsForTLSSubscription1TLSConfigurationInput struct {
	Data *RelationshipMemberTLSConfigurationInput `json:"data,omitempty"`
}

func (o *RelationshipsForTLSSubscription1TLSConfigurationInput) GetData() *RelationshipMemberTLSConfigurationInput {
	if o == nil {
		return nil
	}
	return o.Data
}

// RelationshipsForTLSSubscription1Input - The unique identifier for the set of TLS configuration options that apply to the enabled domains on this subscription. Write-only on create.
type RelationshipsForTLSSubscription1Input struct {
	TLSConfiguration *RelationshipsForTLSSubscription1TLSConfigurationInput `json:"tls_configuration,omitempty"`
}

func (o *RelationshipsForTLSSubscription1Input) GetTLSConfiguration() *RelationshipsForTLSSubscription1TLSConfigurationInput {
	if o == nil {
		return nil
	}
	return o.TLSConfiguration
}

type RelationshipsForTLSSubscriptionInputType string

const (
	RelationshipsForTLSSubscriptionInputTypeRelationshipsForTLSSubscription1Input RelationshipsForTLSSubscriptionInputType = "relationships_for_tls_subscription_1Input"
	RelationshipsForTLSSubscriptionInputTypeRelationshipsForTLSSubscription2Input RelationshipsForTLSSubscriptionInputType = "relationships_for_tls_subscription_2Input"
	RelationshipsForTLSSubscriptionInputTypeRelationshipTLSDomainsInput           RelationshipsForTLSSubscriptionInputType = "relationship_tls_domainsInput"
	RelationshipsForTLSSubscriptionInputTypeRelationshipTLSCertificatesInput      RelationshipsForTLSSubscriptionInputType = "relationship_tls_certificatesInput"
)

type RelationshipsForTLSSubscriptionInput struct {
	RelationshipsForTLSSubscription1Input *RelationshipsForTLSSubscription1Input
	RelationshipsForTLSSubscription2Input *RelationshipsForTLSSubscription2Input
	RelationshipTLSDomainsInput           *RelationshipTLSDomainsInput
	RelationshipTLSCertificatesInput      *RelationshipTLSCertificatesInput

	Type RelationshipsForTLSSubscriptionInputType
}

func CreateRelationshipsForTLSSubscriptionInputRelationshipsForTLSSubscription1Input(relationshipsForTLSSubscription1Input RelationshipsForTLSSubscription1Input) RelationshipsForTLSSubscriptionInput {
	typ := RelationshipsForTLSSubscriptionInputTypeRelationshipsForTLSSubscription1Input

	return RelationshipsForTLSSubscriptionInput{
		RelationshipsForTLSSubscription1Input: &relationshipsForTLSSubscription1Input,
		Type:                                  typ,
	}
}

func CreateRelationshipsForTLSSubscriptionInputRelationshipsForTLSSubscription2Input(relationshipsForTLSSubscription2Input RelationshipsForTLSSubscription2Input) RelationshipsForTLSSubscriptionInput {
	typ := RelationshipsForTLSSubscriptionInputTypeRelationshipsForTLSSubscription2Input

	return RelationshipsForTLSSubscriptionInput{
		RelationshipsForTLSSubscription2Input: &relationshipsForTLSSubscription2Input,
		Type:                                  typ,
	}
}

func CreateRelationshipsForTLSSubscriptionInputRelationshipTLSDomainsInput(relationshipTLSDomainsInput RelationshipTLSDomainsInput) RelationshipsForTLSSubscriptionInput {
	typ := RelationshipsForTLSSubscriptionInputTypeRelationshipTLSDomainsInput

	return RelationshipsForTLSSubscriptionInput{
		RelationshipTLSDomainsInput: &relationshipTLSDomainsInput,
		Type:                        typ,
	}
}

func CreateRelationshipsForTLSSubscriptionInputRelationshipTLSCertificatesInput(relationshipTLSCertificatesInput RelationshipTLSCertificatesInput) RelationshipsForTLSSubscriptionInput {
	typ := RelationshipsForTLSSubscriptionInputTypeRelationshipTLSCertificatesInput

	return RelationshipsForTLSSubscriptionInput{
		RelationshipTLSCertificatesInput: &relationshipTLSCertificatesInput,
		Type:                             typ,
	}
}

func (u *RelationshipsForTLSSubscriptionInput) UnmarshalJSON(data []byte) error {

	relationshipsForTLSSubscription1Input := new(RelationshipsForTLSSubscription1Input)
	if err := utils.UnmarshalJSON(data, &relationshipsForTLSSubscription1Input, "", true, true); err == nil {
		u.RelationshipsForTLSSubscription1Input = relationshipsForTLSSubscription1Input
		u.Type = RelationshipsForTLSSubscriptionInputTypeRelationshipsForTLSSubscription1Input
		return nil
	}

	relationshipsForTLSSubscription2Input := new(RelationshipsForTLSSubscription2Input)
	if err := utils.UnmarshalJSON(data, &relationshipsForTLSSubscription2Input, "", true, true); err == nil {
		u.RelationshipsForTLSSubscription2Input = relationshipsForTLSSubscription2Input
		u.Type = RelationshipsForTLSSubscriptionInputTypeRelationshipsForTLSSubscription2Input
		return nil
	}

	relationshipTLSDomainsInput := new(RelationshipTLSDomainsInput)
	if err := utils.UnmarshalJSON(data, &relationshipTLSDomainsInput, "", true, true); err == nil {
		u.RelationshipTLSDomainsInput = relationshipTLSDomainsInput
		u.Type = RelationshipsForTLSSubscriptionInputTypeRelationshipTLSDomainsInput
		return nil
	}

	relationshipTLSCertificatesInput := new(RelationshipTLSCertificatesInput)
	if err := utils.UnmarshalJSON(data, &relationshipTLSCertificatesInput, "", true, true); err == nil {
		u.RelationshipTLSCertificatesInput = relationshipTLSCertificatesInput
		u.Type = RelationshipsForTLSSubscriptionInputTypeRelationshipTLSCertificatesInput
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RelationshipsForTLSSubscriptionInput) MarshalJSON() ([]byte, error) {
	if u.RelationshipsForTLSSubscription1Input != nil {
		return utils.MarshalJSON(u.RelationshipsForTLSSubscription1Input, "", true)
	}

	if u.RelationshipsForTLSSubscription2Input != nil {
		return utils.MarshalJSON(u.RelationshipsForTLSSubscription2Input, "", true)
	}

	if u.RelationshipTLSDomainsInput != nil {
		return utils.MarshalJSON(u.RelationshipTLSDomainsInput, "", true)
	}

	if u.RelationshipTLSCertificatesInput != nil {
		return utils.MarshalJSON(u.RelationshipTLSCertificatesInput, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}
