// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"Fastly/internal/utils"
	"encoding/json"
	"fmt"
	"time"
)

// RateLimiterResponseAction - The action to take when a rate limiter violation is detected.
type RateLimiterResponseAction string

const (
	RateLimiterResponseActionResponse       RateLimiterResponseAction = "response"
	RateLimiterResponseActionResponseObject RateLimiterResponseAction = "response_object"
	RateLimiterResponseActionLogOnly        RateLimiterResponseAction = "log_only"
)

func (e RateLimiterResponseAction) ToPointer() *RateLimiterResponseAction {
	return &e
}

func (e *RateLimiterResponseAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "response":
		fallthrough
	case "response_object":
		fallthrough
	case "log_only":
		*e = RateLimiterResponseAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RateLimiterResponseAction: %v", v)
	}
}

type HTTPMethods string

const (
	HTTPMethodsHead    HTTPMethods = "HEAD"
	HTTPMethodsOptions HTTPMethods = "OPTIONS"
	HTTPMethodsGet     HTTPMethods = "GET"
	HTTPMethodsPost    HTTPMethods = "POST"
	HTTPMethodsPut     HTTPMethods = "PUT"
	HTTPMethodsPatch   HTTPMethods = "PATCH"
	HTTPMethodsDelete  HTTPMethods = "DELETE"
	HTTPMethodsTrace   HTTPMethods = "TRACE"
)

func (e HTTPMethods) ToPointer() *HTTPMethods {
	return &e
}

func (e *HTTPMethods) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HEAD":
		fallthrough
	case "OPTIONS":
		fallthrough
	case "GET":
		fallthrough
	case "POST":
		fallthrough
	case "PUT":
		fallthrough
	case "PATCH":
		fallthrough
	case "DELETE":
		fallthrough
	case "TRACE":
		*e = HTTPMethods(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HTTPMethods: %v", v)
	}
}

// LoggerType - Name of the type of logging endpoint to be used when action is `log_only`. The logging endpoint type is used to determine the appropriate log format to use when emitting log entries.
type LoggerType string

const (
	LoggerTypeAzureblob       LoggerType = "azureblob"
	LoggerTypeBigquery        LoggerType = "bigquery"
	LoggerTypeCloudfiles      LoggerType = "cloudfiles"
	LoggerTypeDatadog         LoggerType = "datadog"
	LoggerTypeDigitalocean    LoggerType = "digitalocean"
	LoggerTypeElasticsearch   LoggerType = "elasticsearch"
	LoggerTypeFtp             LoggerType = "ftp"
	LoggerTypeGcs             LoggerType = "gcs"
	LoggerTypeGoogleanalytics LoggerType = "googleanalytics"
	LoggerTypeHeroku          LoggerType = "heroku"
	LoggerTypeHoneycomb       LoggerType = "honeycomb"
	LoggerTypeHTTP            LoggerType = "http"
	LoggerTypeHTTPS           LoggerType = "https"
	LoggerTypeKafka           LoggerType = "kafka"
	LoggerTypeKinesis         LoggerType = "kinesis"
	LoggerTypeLogentries      LoggerType = "logentries"
	LoggerTypeLoggly          LoggerType = "loggly"
	LoggerTypeLogshuttle      LoggerType = "logshuttle"
	LoggerTypeNewrelic        LoggerType = "newrelic"
	LoggerTypeOpenstack       LoggerType = "openstack"
	LoggerTypePapertrail      LoggerType = "papertrail"
	LoggerTypePubsub          LoggerType = "pubsub"
	LoggerTypeS3              LoggerType = "s3"
	LoggerTypeScalyr          LoggerType = "scalyr"
	LoggerTypeSftp            LoggerType = "sftp"
	LoggerTypeSplunk          LoggerType = "splunk"
	LoggerTypeStackdriver     LoggerType = "stackdriver"
	LoggerTypeSumologic       LoggerType = "sumologic"
	LoggerTypeSyslog          LoggerType = "syslog"
)

func (e LoggerType) ToPointer() *LoggerType {
	return &e
}

func (e *LoggerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azureblob":
		fallthrough
	case "bigquery":
		fallthrough
	case "cloudfiles":
		fallthrough
	case "datadog":
		fallthrough
	case "digitalocean":
		fallthrough
	case "elasticsearch":
		fallthrough
	case "ftp":
		fallthrough
	case "gcs":
		fallthrough
	case "googleanalytics":
		fallthrough
	case "heroku":
		fallthrough
	case "honeycomb":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "kafka":
		fallthrough
	case "kinesis":
		fallthrough
	case "logentries":
		fallthrough
	case "loggly":
		fallthrough
	case "logshuttle":
		fallthrough
	case "newrelic":
		fallthrough
	case "openstack":
		fallthrough
	case "papertrail":
		fallthrough
	case "pubsub":
		fallthrough
	case "s3":
		fallthrough
	case "scalyr":
		fallthrough
	case "sftp":
		fallthrough
	case "splunk":
		fallthrough
	case "stackdriver":
		fallthrough
	case "sumologic":
		fallthrough
	case "syslog":
		*e = LoggerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LoggerType: %v", v)
	}
}

// RateLimiterResponseResponse - Custom response to be sent when the rate limit is exceeded. Required if `action` is `response`.
type RateLimiterResponseResponse struct {
	// Response body for custom limit enforcement response.
	Content *string `json:"content,omitempty"`
	// MIME type for custom limit enforcement response.
	ContentType *string `json:"content_type,omitempty"`
	// HTTP status code for custom limit enforcement response.
	Status *int64 `json:"status,omitempty"`
}

func (o *RateLimiterResponseResponse) GetContent() *string {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *RateLimiterResponseResponse) GetContentType() *string {
	if o == nil {
		return nil
	}
	return o.ContentType
}

func (o *RateLimiterResponseResponse) GetStatus() *int64 {
	if o == nil {
		return nil
	}
	return o.Status
}

// WindowSize - Number of seconds during which the RPS limit must be exceeded in order to trigger a violation.
type WindowSize int64

const (
	WindowSizeOne   WindowSize = 1
	WindowSizeTen   WindowSize = 10
	WindowSizeSixty WindowSize = 60
)

func (e WindowSize) ToPointer() *WindowSize {
	return &e
}

func (e *WindowSize) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		fallthrough
	case 10:
		fallthrough
	case 60:
		*e = WindowSize(v)
		return nil
	default:
		return fmt.Errorf("invalid value for WindowSize: %v", v)
	}
}

type RateLimiterResponse struct {
	// The action to take when a rate limiter violation is detected.
	Action *RateLimiterResponseAction `json:"action,omitempty"`
	// Array of VCL variables used to generate a counter key to identify a client. Example variables include `req.http.Fastly-Client-IP`, `req.http.User-Agent`, or a custom header like `req.http.API-Key`.
	ClientKey []string `json:"client_key,omitempty"`
	// Date and time in ISO 8601 format.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// Date and time in ISO 8601 format.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// Revision number of the rate limiting feature implementation. Defaults to the most recent revision.
	FeatureRevision *int64 `json:"feature_revision,omitempty"`
	// Array of HTTP methods to apply rate limiting to.
	HTTPMethods []HTTPMethods `json:"http_methods,omitempty"`
	// Alphanumeric string identifying the rate limiter.
	ID *string `json:"id,omitempty"`
	// Name of the type of logging endpoint to be used when action is `log_only`. The logging endpoint type is used to determine the appropriate log format to use when emitting log entries.
	LoggerType *LoggerType `json:"logger_type,omitempty"`
	// A human readable name for the rate limiting rule.
	Name *string `json:"name,omitempty"`
	// Length of time in minutes that the rate limiter is in effect after the initial violation is detected.
	PenaltyBoxDuration *int64 `json:"penalty_box_duration,omitempty"`
	// Custom response to be sent when the rate limit is exceeded. Required if `action` is `response`.
	Response *RateLimiterResponseResponse `json:"response,omitempty"`
	// Name of existing response object. Required if `action` is `response_object`. Note that the rate limiter response is only updated to reflect the response object content when saving the rate limiter configuration.
	ResponseObjectName *string `json:"response_object_name,omitempty"`
	// Upper limit of requests per second allowed by the rate limiter.
	RpsLimit  *int64  `json:"rps_limit,omitempty"`
	ServiceID *string `json:"service_id,omitempty"`
	// Date and time in ISO 8601 format.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	// The name of an Edge Dictionary containing URIs as keys. If not defined or `null`, all origin URIs will be rate limited.
	URIDictionaryName *string `json:"uri_dictionary_name,omitempty"`
	Version           *int64  `json:"version,omitempty"`
	// Number of seconds during which the RPS limit must be exceeded in order to trigger a violation.
	WindowSize *WindowSize `json:"window_size,omitempty"`
}

func (r RateLimiterResponse) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RateLimiterResponse) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *RateLimiterResponse) GetAction() *RateLimiterResponseAction {
	if o == nil {
		return nil
	}
	return o.Action
}

func (o *RateLimiterResponse) GetClientKey() []string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *RateLimiterResponse) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *RateLimiterResponse) GetDeletedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *RateLimiterResponse) GetFeatureRevision() *int64 {
	if o == nil {
		return nil
	}
	return o.FeatureRevision
}

func (o *RateLimiterResponse) GetHTTPMethods() []HTTPMethods {
	if o == nil {
		return nil
	}
	return o.HTTPMethods
}

func (o *RateLimiterResponse) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *RateLimiterResponse) GetLoggerType() *LoggerType {
	if o == nil {
		return nil
	}
	return o.LoggerType
}

func (o *RateLimiterResponse) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *RateLimiterResponse) GetPenaltyBoxDuration() *int64 {
	if o == nil {
		return nil
	}
	return o.PenaltyBoxDuration
}

func (o *RateLimiterResponse) GetResponse() *RateLimiterResponseResponse {
	if o == nil {
		return nil
	}
	return o.Response
}

func (o *RateLimiterResponse) GetResponseObjectName() *string {
	if o == nil {
		return nil
	}
	return o.ResponseObjectName
}

func (o *RateLimiterResponse) GetRpsLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.RpsLimit
}

func (o *RateLimiterResponse) GetServiceID() *string {
	if o == nil {
		return nil
	}
	return o.ServiceID
}

func (o *RateLimiterResponse) GetUpdatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *RateLimiterResponse) GetURIDictionaryName() *string {
	if o == nil {
		return nil
	}
	return o.URIDictionaryName
}

func (o *RateLimiterResponse) GetVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *RateLimiterResponse) GetWindowSize() *WindowSize {
	if o == nil {
		return nil
	}
	return o.WindowSize
}
